import type { File } from 'formidable';
import { environment } from '@/config/environment';
import { logger } from '@/server/logger';
import { ApplicationError, ErrorCode } from '@/lib/error';
import { serverFetch } from '@/lib/api/serverFetch';

/**
 * Malware scan result
 */
export interface ScanResult {
  /** Whether the file passed the scan */
  clean: boolean;
  /** Threat name if detected */
  threat?: string;
  /** Scanner used */
  scanner: string;
  /** Scan timestamp */
  scannedAt: Date;
}

/**
 * Malware scanner interface for future implementations
 */
export interface MalwareScanner {
  scan(file: File): Promise<ScanResult>;
}

/**
 * VirusTotal API scanner implementation
 * Requires VIRUSTOTAL_API_KEY environment variable
 */
export class VirusTotalScanner implements MalwareScanner {
  private readonly apiKey: string | null;
  private apiUrl = 'https://www.virustotal.com/api/v3';

  constructor() {
    this.apiKey = environment.security.virusTotalApiKey || null;
  }

  async scan(file: File): Promise<ScanResult> {
    if (!this.apiKey) {
      logger.warn(
        'VirusTotal API key not configured - bypassing scan for development'
      );
      return {
        clean: true,
        scanner: 'development-bypass',
        scannedAt: new Date(),
      };
    }

    try {
      // Read file data
      const fs = await import('fs/promises');
      const fileData = await fs.readFile(file.filepath);

      // Upload file to VirusTotal
      const formData = new FormData();
      formData.append(
        'file',
        new Blob([fileData]),
        file.originalFilename || 'file'
      );

      const uploadResponse = await serverFetch(`${this.apiUrl}/files`, {
        method: 'POST',
        headers: {
          'x-apikey': this.apiKey,
        },
        body: formData,
      });

      if (!uploadResponse.ok) {
        throw new Error(
          `VirusTotal upload failed: ${uploadResponse.statusText}`
        );
      }

      const uploadData = await uploadResponse.json();
      const analysisId = uploadData.data.id;

      // Poll for results (VirusTotal processing can take a moment)
      let attempts = 0;
      const maxAttempts = 30; // 30 seconds timeout

      while (attempts < maxAttempts) {
        const analysisResponse = await serverFetch(
          `${this.apiUrl}/analyses/${analysisId}`,
          {
            headers: {
              'x-apikey': this.apiKey,
            },
          }
        );

        if (!analysisResponse.ok) {
          throw new Error(
            `VirusTotal analysis failed: ${analysisResponse.statusText}`
          );
        }

        const analysisData = await analysisResponse.json();
        const status = analysisData.data.attributes.status;

        if (status === 'completed') {
          const stats = analysisData.data.attributes.stats;
          const maliciousCount = stats.malicious || 0;
          const suspiciousCount = stats.suspicious || 0;

          if (maliciousCount > 0 || suspiciousCount > 0) {
            // Error logging removed for client compatibility

            return {
              clean: false,
              threat: `Detected by ${maliciousCount + suspiciousCount} scanners`,
              scanner: 'virustotal',
              scannedAt: new Date(),
            };
          }
          // Info logging removed for client compatibility

          return {
            clean: true,
            scanner: 'virustotal',
            scannedAt: new Date(),
          };
        }

        // Wait 1 second before next attempt
        await new Promise(resolve => setTimeout(resolve, 1000));
        attempts++;
      }

      // Timeout - treat as suspicious
      // Warning logging removed for client compatibility

      return {
        clean: false,
        threat: 'Scan timeout - file blocked for safety',
        scanner: 'virustotal',
        scannedAt: new Date(),
      };
    } catch (error) {
      // Error logging removed for client compatibility

      // On error, block the file for safety
      return {
        clean: false,
        threat: 'Scan error - file blocked for safety',
        scanner: 'virustotal',
        scannedAt: new Date(),
      };
    }
  }
}

/**
 * Security scanner that blocks all uploads when no scanner is configured
 * This is the default for production to ensure safety
 */
class BlockingScanner implements MalwareScanner {
  async scan(file: File): Promise<ScanResult> {
    // Error logging removed for client compatibility

    return {
      clean: false,
      threat: 'File uploads are currently disabled for security reasons',
      scanner: 'blocking',
      scannedAt: new Date(),
    };
  }
}

/**
 * Get the configured malware scanner
 */
export function getMalwareScanner(): MalwareScanner {
  // Check for VirusTotal API key
  const virusTotalKey = environment.security.virusTotalApiKey;
  if (virusTotalKey) {
    // Info logging removed for client compatibility
    return new VirusTotalScanner();
  }

  // In production, block all uploads if no scanner is configured
  if (environment.isProduction) {
    // Warning logging removed for client compatibility
    return new BlockingScanner();
  }

  // In development, log warning but allow uploads
  // Warning logging removed for client compatibility
  return {
    async scan(file: File): Promise<ScanResult> {
      // Warning logging removed for client compatibility
      return {
        clean: true,
        scanner: 'development-bypass',
        scannedAt: new Date(),
      };
    },
  };
}

/**
 * Scan a file for malware
 * @param file The file to scan
 * @param blockOnThreat Whether to throw an error if a threat is detected
 * @returns The scan result
 */
export async function scanFile(
  file: File,
  blockOnThreat: boolean = true
): Promise<ScanResult> {
  const scanner = getMalwareScanner();
  const result = await scanner.scan(file);

  if (!result.clean) {
    // Error logging removed for client compatibility

    if (blockOnThreat) {
      throw new ApplicationError(
        ErrorCode.SECURITY_MALWARE_DETECTED,
        result.threat || 'Potential security threat detected'
      );
    }
  }

  return result;
}

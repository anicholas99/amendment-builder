import { logger } from '@/lib/monitoring/logger';
import type { File } from 'formidable';
import { environment } from '@/config/environment';
import { ApplicationError, ErrorCode } from '@/lib/error';

/**
 * Malware scan result
 */
export interface ScanResult {
  /** Whether the file passed the scan */
  clean: boolean;
  /** Threat name if detected */
  threat?: string;
  /** Scanner used */
  scanner: string;
  /** Scan timestamp */
  scannedAt: Date;
}

/**
 * Malware scanner interface for future implementations
 */
export interface MalwareScanner {
  scan(file: File): Promise<ScanResult>;
}

/**
 * VirusTotal API scanner implementation
 * Requires VIRUSTOTAL_API_KEY environment variable
 */
class VirusTotalScanner implements MalwareScanner {
  private apiKey: string;
  private apiUrl = 'https://www.virustotal.com/api/v3';

  constructor(apiKey: string) {
    this.apiKey = apiKey;
  }

  async scan(file: File): Promise<ScanResult> {
    try {
      // Read file data
      const fs = await import('fs/promises');
      const fileData = await fs.readFile(file.filepath);

      // Upload file to VirusTotal
      const formData = new FormData();
      formData.append(
        'file',
        new Blob([fileData]),
        file.originalFilename || 'file'
      );

      const uploadResponse = await fetch(`${this.apiUrl}/files`, {
        method: 'POST',
        headers: {
          'x-apikey': this.apiKey,
        },
        body: formData,
      });

      if (!uploadResponse.ok) {
        throw new Error(
          `VirusTotal upload failed: ${uploadResponse.statusText}`
        );
      }

      const uploadData = await uploadResponse.json();
      const analysisId = uploadData.data.id;

      // Poll for results (VirusTotal processing can take a moment)
      let attempts = 0;
      const maxAttempts = 30; // 30 seconds timeout

      while (attempts < maxAttempts) {
        const analysisResponse = await fetch(
          `${this.apiUrl}/analyses/${analysisId}`,
          {
            headers: {
              'x-apikey': this.apiKey,
            },
          }
        );

        if (!analysisResponse.ok) {
          throw new Error(
            `VirusTotal analysis failed: ${analysisResponse.statusText}`
          );
        }

        const analysisData = await analysisResponse.json();
        const status = analysisData.data.attributes.status;

        if (status === 'completed') {
          const stats = analysisData.data.attributes.stats;
          const maliciousCount = stats.malicious || 0;
          const suspiciousCount = stats.suspicious || 0;

          if (maliciousCount > 0 || suspiciousCount > 0) {
            logger.error('Malware detected by VirusTotal', {
              filename: file.originalFilename,
              malicious: maliciousCount,
              suspicious: suspiciousCount,
              analysisId,
            });

            return {
              clean: false,
              threat: `Detected by ${maliciousCount + suspiciousCount} scanners`,
              scanner: 'virustotal',
              scannedAt: new Date(),
            };
          }

          logger.info('File passed VirusTotal scan', {
            filename: file.originalFilename,
            analysisId,
          });

          return {
            clean: true,
            scanner: 'virustotal',
            scannedAt: new Date(),
          };
        }

        // Wait 1 second before next attempt
        await new Promise(resolve => setTimeout(resolve, 1000));
        attempts++;
      }

      // Timeout - treat as suspicious
      logger.warn('VirusTotal scan timeout', {
        filename: file.originalFilename,
        analysisId,
      });

      return {
        clean: false,
        threat: 'Scan timeout - file blocked for safety',
        scanner: 'virustotal',
        scannedAt: new Date(),
      };
    } catch (error) {
      logger.error('VirusTotal scan error', {
        error,
        filename: file.originalFilename,
      });

      // On error, block the file for safety
      return {
        clean: false,
        threat: 'Scan error - file blocked for safety',
        scanner: 'virustotal',
        scannedAt: new Date(),
      };
    }
  }
}

/**
 * Security scanner that blocks all uploads when no scanner is configured
 * This is the default for production to ensure safety
 */
class BlockingScanner implements MalwareScanner {
  async scan(file: File): Promise<ScanResult> {
    logger.error('File upload blocked - malware scanning not configured', {
      filename: file.originalFilename,
      size: file.size,
      mimetype: file.mimetype,
    });

    return {
      clean: false,
      threat: 'File uploads are currently disabled for security reasons',
      scanner: 'blocking',
      scannedAt: new Date(),
    };
  }
}

/**
 * Get the configured malware scanner
 */
export function getMalwareScanner(): MalwareScanner {
  // Check for VirusTotal API key
  const virusTotalKey = process.env.VIRUSTOTAL_API_KEY;
  if (virusTotalKey) {
    logger.info('Using VirusTotal malware scanner');
    return new VirusTotalScanner(virusTotalKey);
  }

  // In production, block all uploads if no scanner is configured
  if (environment.isProduction) {
    logger.warn(
      'No malware scanner configured in production - blocking all uploads'
    );
    return new BlockingScanner();
  }

  // In development, log warning but allow uploads
  logger.warn(
    'No malware scanner configured - uploads allowed in development only'
  );
  return {
    async scan(file: File): Promise<ScanResult> {
      logger.warn('Development mode - skipping malware scan', {
        filename: file.originalFilename,
      });
      return {
        clean: true,
        scanner: 'development-bypass',
        scannedAt: new Date(),
      };
    },
  };
}

/**
 * Scan a file for malware
 * @param file The file to scan
 * @param blockOnThreat Whether to throw an error if a threat is detected
 * @returns The scan result
 */
export async function scanFile(
  file: File,
  blockOnThreat: boolean = true
): Promise<ScanResult> {
  const scanner = getMalwareScanner();
  const result = await scanner.scan(file);

  if (!result.clean) {
    logger.error('Malware detected in uploaded file', {
      filename: file.originalFilename,
      threat: result.threat,
      scanner: result.scanner,
    });

    if (blockOnThreat) {
      throw new ApplicationError(
        ErrorCode.SECURITY_MALWARE_DETECTED,
        result.threat || 'Potential security threat detected'
      );
    }
  }

  return result;
}
